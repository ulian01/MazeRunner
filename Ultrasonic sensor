#include <Arduino.h>

#define LEFT_BWD   9
#define LEFT_FWD   6
#define RIGHT_BWD  5
#define RIGHT_FWD  3
#define ECHO       12
#define TRIG       4
#define SERVO_PIN  8

const int FORWARD_SPEED       = 150;
const int FORWARD_SPEED_WEAK  = 155;
const int TURN_SPEED          = 170;
const int TURN_SPEED_WEAK     = 175;
const float WALL_DIST         = 10.0;
const float CLEAR_DIST        = 30.0;
const float EXIT_DIST         = 50.0; // Distance to consider an "exit"
const unsigned long TURN_90_LEFT  = 525;
const unsigned long TURN_90_RIGHT = 675;
const unsigned long BACK_TIME = 500;
const unsigned long FORWARD_PASS = 600;

volatile bool scanningActive = false;

// Head State Machine
int headState = 0; // 0=Center, 1=Right, 2=Left
unsigned long headStateStart = 0;
float currentDistance = 0;
bool isGlancing = false;

// ---------------- MOTOR FUNCTIONS ----------------
void forwardMove();
void backwardMove();
void stopMotors();
void turnLeft();
void turnRight();
float readDistance();
float readDistanceFiltered();
void startTurnLeft(unsigned long duration);
void startTurnRight(unsigned long duration);

// ---------------- SERVO ----------------
void servoWrite(int angle) {
  angle = constrain(angle, 0, 180);
  int pulse = map(angle, 0, 180, 500, 2500);
  digitalWrite(SERVO_PIN, HIGH);
  delayMicroseconds(pulse);
  digitalWrite(SERVO_PIN, LOW);
  delayMicroseconds(20000 - pulse);
}

// Helper to move servo and hold it for a duration (ensures it reaches position)
void moveServo(int angle, unsigned long duration) {
  unsigned long start = millis();
  while (millis() - start < duration) {
    servoWrite(angle);
  }
}

void neckScan() {
  // Replaced by state machine in loop
}

int findBestDirection() {
  scanningActive = true;
  isGlancing = false; // Reset glance state
  headState = 0;      // Reset head to center

  float leftDist = 0, rightDist = 0;

  // Move to Right and hold to ensure it gets there
  moveServo(10, 300);
  rightDist = readDistanceFiltered();

  // Move to Left
  moveServo(130, 300);
  leftDist = readDistanceFiltered();

  // Back to Center
  moveServo(70, 150);

  scanningActive = false;

  bool canGoRight = rightDist > CLEAR_DIST;
  bool canGoLeft  = leftDist > CLEAR_DIST;

  if (canGoRight && canGoLeft) {
    return (rightDist > leftDist) ? 10 : 130;
  } else if (canGoRight) {
    return 10;
  } else if (canGoLeft) {
    return 130;
  } else {
    return 0;
  }
}

// ---------------- STATE MACHINE ----------------
enum RobotState { MOVING_FORWARD, TURNING_LEFT, TURNING_RIGHT, BACKING_UP };
RobotState currentState = MOVING_FORWARD;
unsigned long actionStartTime = 0;
unsigned long actionDuration  = 0;

// ---------------- NON-BLOCKING ACTION START ----------------
void startTurnLeft(unsigned long duration) {
  turnLeft();
  currentState = TURNING_LEFT;
  actionStartTime = millis();
  actionDuration = duration;
}

void startTurnRight(unsigned long duration) {
  turnRight();
  currentState = TURNING_RIGHT;
  actionStartTime = millis();
  actionDuration = duration;
}

void startBackward(unsigned long duration) {
  backwardMove();
  currentState = BACKING_UP;
  actionStartTime = millis();
  actionDuration = duration;
}

// ---------------- SETUP ----------------
void setup() {
  pinMode(LEFT_FWD, OUTPUT);
  pinMode(LEFT_BWD, OUTPUT);
  pinMode(RIGHT_FWD, OUTPUT);
  pinMode(RIGHT_BWD, OUTPUT);
  pinMode(TRIG, OUTPUT);
  pinMode(ECHO, INPUT);
  pinMode(SERVO_PIN, OUTPUT);

  Serial.begin(9600);
  servoWrite(70);
  stopMotors();
}

void checkStuck(unsigned long now);

// ---------------- LOOP ----------------
void loop() {
  unsigned long now = millis();

  if (currentState == MOVING_FORWARD) {
      servoWrite(70); // Keep head centered
      currentDistance = readDistanceFiltered();
      
      // If we see a wall in front, STOP immediately
      if (currentDistance > 0 && currentDistance < WALL_DIST) {
         stopMotors();
         // Handle Wall Logic
         int bestAngle = findBestDirection();
         if (bestAngle == 10) {
            startTurnRight(TURN_90_RIGHT);
         } else if (bestAngle == 130) {
            startTurnLeft(TURN_90_LEFT);
         } else {
            // 3 walls (Dead End) -> Turn 180 degrees
            startTurnRight(TURN_90_RIGHT * 2);
         }
         return; // Restart loop
      }
  } else {
    // If turning/backing, just keep head centered
    servoWrite(70);
  }

  // Check if current action finished
  if (currentState != MOVING_FORWARD && now - actionStartTime >= actionDuration) {
    stopMotors();
    currentState = MOVING_FORWARD;
  }

  checkStuck(now);

  // Keep moving forward if nothing else
  if (currentState == MOVING_FORWARD) forwardMove();
}

void checkStuck(unsigned long now) {
  static float lastDistance = 0;
  static unsigned long lastCheck = 0;
  static int stuckCounter = 0;

  if (currentState == MOVING_FORWARD && (now - lastCheck > 120)) {
    lastCheck = now;
    float distNow = readDistance(); // Single read is enough for stuck check
    
    // Only count as stuck if we have a valid reading that isn't changing
    // Ignore 0 (too far) to prevent false positives in open spaces
    if (distNow > 0 && distNow < 200 && abs(distNow - lastDistance) < 1.5) {
      stuckCounter++;
    } else {
      stuckCounter = 0;
    }
    lastDistance = distNow;

    if (stuckCounter > 6) {
      stopMotors();
      startBackward(800); // More aggressive backup
      // Random turn to get unstuck
      if (millis() % 2 == 0) {
        startTurnRight(TURN_90_RIGHT + 200);
      } else {
        startTurnLeft(TURN_90_LEFT + 200);
      }
      stuckCounter = 0;
    }
  }
}

// ---------------- MOTOR IMPLEMENTATION ----------------
void forwardMove() {
  analogWrite(LEFT_FWD, FORWARD_SPEED_WEAK);
  analogWrite(RIGHT_FWD, FORWARD_SPEED);
  analogWrite(LEFT_BWD, 0);
  analogWrite(RIGHT_BWD, 0);
}

void backwardMove() {
  analogWrite(LEFT_BWD, FORWARD_SPEED_WEAK);
  analogWrite(RIGHT_BWD, FORWARD_SPEED);
  analogWrite(LEFT_FWD, 0);
  analogWrite(RIGHT_FWD, 0);
}

void stopMotors() {
  analogWrite(LEFT_FWD, 0);
  analogWrite(RIGHT_FWD, 0);
  analogWrite(LEFT_BWD, 0);
  analogWrite(RIGHT_BWD, 0);
}

void turnRight() {
  analogWrite(LEFT_FWD, TURN_SPEED_WEAK);
  analogWrite(RIGHT_BWD, TURN_SPEED);
  analogWrite(RIGHT_FWD, 0);
  analogWrite(LEFT_BWD, 0);
}

void turnLeft() {
  analogWrite(RIGHT_FWD, TURN_SPEED);
  analogWrite(LEFT_BWD, TURN_SPEED_WEAK);
  analogWrite(LEFT_FWD, 0);
  analogWrite(RIGHT_BWD, 0);
}

// ---------------- ULTRASONIC ----------------
float readDistance() {
  digitalWrite(TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG, LOW);

  // Reduced timeout to ~18ms (approx 3 meters) to speed up loop
  long duration = pulseIn(ECHO, HIGH, 18000); 
  if (duration == 0) return 0;
  return duration * 0.034 / 2.0;
}

float readDistanceFiltered() {
  float d1 = readDistance();
  delay(3);
  float d2 = readDistance();
  delay(3);
  float d3 = readDistance();

  // Median filter to remove noise spikes
  if ((d1 <= d2 && d2 <= d3) || (d3 <= d2 && d2 <= d1)) return d2;
  if ((d2 <= d1 && d1 <= d3) || (d3 <= d1 && d1 <= d2)) return d1;
  return d3;
}


